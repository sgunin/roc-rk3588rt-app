<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="custom-style.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
	<div style="overflow: hidden;">
		<div style="height: 57px;min-width: 1039px;background-size: auto 100%;background:url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABwgAAAABCAYAAADKO/rAAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAABRSURBVFhH7dUxCoBADEXB5LK5/w1iIaLIrsgWNs50Sf/4WVUd8HOZGd1nCqMbGNMPrNMPrJv1cvz0A3OjfuwPvDPrxf7A7t7IlX7gmX74VsQGguw4S6+UnSYAAAAASUVORK5CYII=');">
			<img src="titleleft.png" style="float: left;"/>
			<img src="titleright.png" alt="" style="float: right;" />
		</div>
	</div>
<!-- Generated by Doxygen 1.8.15 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Home&#160;Page</span></a></li>
      <li><a href="_xE5_x8F_x91_xE7_x89_x88_xE8_xAF_xB4_xE6_x98_x8E.html"><span>Release&#160;Notes</span></a></li>
      <li><a href="_xE7_x8E_xAF_xE5_xA2_x83_xE9_x85_x8D_xE7_xBD_xAE.html"><span>Environment&#160;Configuration</span></a></li>
      <li><a href="_xE7_xBC_x96_xE7_xA8_x8B_xE5_xBC_x95_xE5_xAF_xBC.html"><span>Programming&#160;Guide</span></a></li>
      <li class="current"><a href="modules.html"><span>API&#160;Reference</span></a></li>
      <li><a href="_xE7_x9B_xB8_xE6_x9C_xBA_xE5_x8F_x82_xE6_x95_xB0_xE8_x8A_x82_xE7_x82_xB9_xE8_xA1_xA8.html"><span>Camera&#160;Parameter&#160;Node&#160;Table</span></a></li>
      <li><a href="_xE7_xA4_xBA_xE4_xBE_x8B_xE7_xA8_x8B_xE5_xBA_x8F_xE6_xA6_x82_xE8_xA7_x88.html"><span>Sample&#160;Program&#160;Overview</span></a></li>
      <li><a href="_xE5_xB8_xB8_xE8_xA7_x81_xE9_x97_xAE_xE9_xA2_x98.html"><span>FAQs</span></a></li>
      <li><a href="_xE6_xB3_x95_xE5_xBE_x8B_xE5_xA3_xB0_xE6_x98_x8E.html"><span>Disclaimer</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Image Acquisition</div>  </div>
</div><!--header-->
<div class="contents">

<p>Acquire images (directly or in callback function), start and stopp acquisition, etc. <br />
 Supports performing ISP algorithm processing on images inside the API via the configuration file generated by the ISP tool. Before using the ISP tool, an ISP plug-in library needs to be installed, and a folder named "ISPTool" needs to be created in the personal directory in the C disk (for example, C:\Users(user name)\ISPTool). In addition, the configuration file generated by camera connecting should be placed in a folder named with the camera model or serial No., inside the ISPTool folder. To get the configuration file, please contact technical support.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga48d1c4ef073e39622fa01994a8fe010c"><td class="memItemLeft" align="right" valign="top">MV_CAMCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga48d1c4ef073e39622fa01994a8fe010c">MV_CC_RegisterImageCallBackEx</a> (IN void *handle, IN void(__stdcall *cbOutput)(unsigned char *pData, <a class="el" href="struct_m_v___f_r_a_m_e___o_u_t___i_n_f_o___e_x.html">MV_FRAME_OUT_INFO_EX</a> *pFrameInfo, void *pUser), IN void *pUser)</td></tr>
<tr class="memdesc:ga48d1c4ef073e39622fa01994a8fe010c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an image data callback, supporting getting chunk information.  <a href="#ga48d1c4ef073e39622fa01994a8fe010c">More...</a><br /></td></tr>
<tr class="separator:ga48d1c4ef073e39622fa01994a8fe010c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78728211c47c6f118110fde635d6ac69"><td class="memItemLeft" align="right" valign="top">MV_CAMCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga78728211c47c6f118110fde635d6ac69">MV_CC_StartGrabbing</a> (IN void *handle)</td></tr>
<tr class="memdesc:ga78728211c47c6f118110fde635d6ac69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start grabbing images.  <a href="#ga78728211c47c6f118110fde635d6ac69">More...</a><br /></td></tr>
<tr class="separator:ga78728211c47c6f118110fde635d6ac69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5d7f4ae46a53851f104e26fa449ab06"><td class="memItemLeft" align="right" valign="top">MV_CAMCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#gae5d7f4ae46a53851f104e26fa449ab06">MV_CC_StopGrabbing</a> (IN void *handle)</td></tr>
<tr class="memdesc:gae5d7f4ae46a53851f104e26fa449ab06"><td class="mdescLeft">&#160;</td><td class="mdescRight">End grabbing images.  <a href="#gae5d7f4ae46a53851f104e26fa449ab06">More...</a><br /></td></tr>
<tr class="separator:gae5d7f4ae46a53851f104e26fa449ab06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33331585a4e2a64653b74af66157a6d8"><td class="memItemLeft" align="right" valign="top">MV_CAMCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga33331585a4e2a64653b74af66157a6d8">MV_CC_GetImageBuffer</a> (IN void *handle, IN OUT <a class="el" href="struct_m_v___f_r_a_m_e___o_u_t.html">MV_FRAME_OUT</a> *pstFrame, IN unsigned int nMsec)</td></tr>
<tr class="memdesc:ga33331585a4e2a64653b74af66157a6d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get one frame of picture using internal buffer.  <a href="#ga33331585a4e2a64653b74af66157a6d8">More...</a><br /></td></tr>
<tr class="separator:ga33331585a4e2a64653b74af66157a6d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeff416b2d35df148fa2e63521d8847d3"><td class="memItemLeft" align="right" valign="top">MV_CAMCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#gaeff416b2d35df148fa2e63521d8847d3">MV_CC_FreeImageBuffer</a> (IN void *handle, IN <a class="el" href="struct_m_v___f_r_a_m_e___o_u_t.html">MV_FRAME_OUT</a> *pstFrame)</td></tr>
<tr class="memdesc:gaeff416b2d35df148fa2e63521d8847d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release image buffer. This API is used to release the image buffer which is no longer used, and it should be used with <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga33331585a4e2a64653b74af66157a6d8" title="Get one frame of picture using internal buffer.">MV_CC_GetImageBuffer()</a> in pairs.  <a href="#gaeff416b2d35df148fa2e63521d8847d3">More...</a><br /></td></tr>
<tr class="separator:gaeff416b2d35df148fa2e63521d8847d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb284e0ae3eeced7e1f9395317800c6f"><td class="memItemLeft" align="right" valign="top">MV_CAMCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#gafb284e0ae3eeced7e1f9395317800c6f">MV_CC_GetOneFrameTimeout</a> (IN void *handle, IN OUT unsigned char *pData, IN unsigned int nDataSize, IN OUT <a class="el" href="struct_m_v___f_r_a_m_e___o_u_t___i_n_f_o___e_x.html">MV_FRAME_OUT_INFO_EX</a> *pstFrameInfo, IN unsigned int nMsec)</td></tr>
<tr class="memdesc:gafb284e0ae3eeced7e1f9395317800c6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get one frame of picture, and the SDK waits internally until data is returned.  <a href="#gafb284e0ae3eeced7e1f9395317800c6f">More...</a><br /></td></tr>
<tr class="separator:gafb284e0ae3eeced7e1f9395317800c6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90fcfa3fb929d76e99ea7f5946d6c5ff"><td class="memItemLeft" align="right" valign="top">MV_CAMCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga90fcfa3fb929d76e99ea7f5946d6c5ff">MV_CC_ClearImageBuffer</a> (IN void *handle)</td></tr>
<tr class="memdesc:ga90fcfa3fb929d76e99ea7f5946d6c5ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the streaming data buffer.  <a href="#ga90fcfa3fb929d76e99ea7f5946d6c5ff">More...</a><br /></td></tr>
<tr class="separator:ga90fcfa3fb929d76e99ea7f5946d6c5ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68d7ec74d6c37907cb868f0ff7f9251e"><td class="memItemLeft" align="right" valign="top">MV_CAMCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga68d7ec74d6c37907cb868f0ff7f9251e">MV_CC_GetValidImageNum</a> (IN void *handle, IN OUT unsigned int *pnValidImageNum)</td></tr>
<tr class="memdesc:ga68d7ec74d6c37907cb868f0ff7f9251e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of valid images in the current image buffer.  <a href="#ga68d7ec74d6c37907cb868f0ff7f9251e">More...</a><br /></td></tr>
<tr class="separator:ga68d7ec74d6c37907cb868f0ff7f9251e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2088ec54d617eb629412729e0241067d"><td class="memItemLeft" align="right" valign="top">MV_CAMCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga2088ec54d617eb629412729e0241067d">MV_CC_SetImageNodeNum</a> (IN void *handle, IN unsigned int nNum)</td></tr>
<tr class="memdesc:ga2088ec54d617eb629412729e0241067d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number of SDK internal image buffer nodes (no less than 1). It should be called before calling <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga78728211c47c6f118110fde635d6ac69" title="Start grabbing images.">MV_CC_StartGrabbing()</a>.  <a href="#ga2088ec54d617eb629412729e0241067d">More...</a><br /></td></tr>
<tr class="separator:ga2088ec54d617eb629412729e0241067d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad337d46cc1955800d4650491ba66e9ce"><td class="memItemLeft" align="right" valign="top">MV_CAMCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#gad337d46cc1955800d4650491ba66e9ce">MV_CC_SetGrabStrategy</a> (IN void *handle, IN <a class="el" href="group___xE6_x9E_x9A_xE4_xB8_xBE_xE7_xB1_xBB_xE5_x9E_x8B_xE5_xAE_x9A_xE4_xB9_x89.html#ga43a073efc6b120886a30b84c96cfa82c">MV_GRAB_STRATEGY</a> enGrabStrategy)</td></tr>
<tr class="memdesc:gad337d46cc1955800d4650491ba66e9ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the streaming strategy. This API is only supported by USB devices.  <a href="#gad337d46cc1955800d4650491ba66e9ce">More...</a><br /></td></tr>
<tr class="separator:gad337d46cc1955800d4650491ba66e9ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d2e6b554356853f307b50b0a0fc3dce"><td class="memItemLeft" align="right" valign="top">MV_CAMCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga2d2e6b554356853f307b50b0a0fc3dce">MV_CC_SetOutputQueueSize</a> (IN void *handle, IN unsigned int nOutputQueueSize)</td></tr>
<tr class="memdesc:ga2d2e6b554356853f307b50b0a0fc3dce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set number of output image buffers, with range of 1 to ImageNodeNum (only valid when <a class="el" href="group___xE6_x9E_x9A_xE4_xB8_xBE_xE7_xB1_xBB_xE5_x9E_x8B_xE5_xAE_x9A_xE4_xB9_x89.html#ga43a073efc6b120886a30b84c96cfa82c" title="Streaming strategy.">MV_GRAB_STRATEGY()</a> is set to MV_GrabStrategy_LatestImages).  <a href="#ga2d2e6b554356853f307b50b0a0fc3dce">More...</a><br /></td></tr>
<tr class="separator:ga2d2e6b554356853f307b50b0a0fc3dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5030eb8498bb2baa031c6b6e8d03406"><td class="memItemLeft" align="right" valign="top">MV_CAMCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#gac5030eb8498bb2baa031c6b6e8d03406">MV_CC_GetPayloadSize</a> (IN void *handle, IN OUT uint64_t *pnPayloadSize, IN OUT unsigned int *pnAlignment)</td></tr>
<tr class="memdesc:gac5030eb8498bb2baa031c6b6e8d03406"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the device payload size (including image data and Chunk data) and memory alignment method, which is used by the application layer to allocate sufficient buffer and correct memory alignment when registering external memory for SDK.  <a href="#gac5030eb8498bb2baa031c6b6e8d03406">More...</a><br /></td></tr>
<tr class="separator:gac5030eb8498bb2baa031c6b6e8d03406"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Acquire images (directly or in callback function), start and stopp acquisition, etc. <br />
 Supports performing ISP algorithm processing on images inside the API via the configuration file generated by the ISP tool. Before using the ISP tool, an ISP plug-in library needs to be installed, and a folder named "ISPTool" needs to be created in the personal directory in the C disk (for example, C:\Users(user name)\ISPTool). In addition, the configuration file generated by camera connecting should be placed in a folder named with the camera model or serial No., inside the ISPTool folder. To get the configuration file, please contact technical support. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga48d1c4ef073e39622fa01994a8fe010c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48d1c4ef073e39622fa01994a8fe010c">&#9670;&nbsp;</a></span>MV_CC_RegisterImageCallBackEx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_CAMCTRL_API int __stdcall MV_CC_RegisterImageCallBackEx </td>
          <td>(</td>
          <td class="paramtype">IN void *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN &#160;</td>
          <td class="paramname"><em>void</em>__stdcall *cbOutput)(unsigned char *pData, MV_FRAME_OUT_INFO_EX *pFrameInfo, void *pUser, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN void *&#160;</td>
          <td class="paramname"><em>pUser</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register an image data callback, supporting getting chunk information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[IN] Device handle. </td></tr>
    <tr><td class="paramname">cbOutput</td><td>[IN] Image data callback function. </td></tr>
    <tr><td class="paramname">pUser</td><td>[IN] User data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return MV_OK for success, and return corresponding <a class="el" href="group___xE9_x94_x99_xE8_xAF_xAF_xE7_xA0_x81.html">error code</a> for failure. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>After calling <a class="el" href="group___xE7_x9B_xB8_xE6_x9C_xBA_xE5_x88_x9D_xE5_xA7_x8B_xE5_x8C_x96.html#gaf10f0644caa6d4dd39fd8c14f8736153" title="Create device handle.">MV_CC_CreateHandle()</a> , call this API to set image data callback function.<br />
 There are two available image data acquisition modes, and cannot be used together: <br />
 Mode 1: Call <a class="el" href="group___xE5_xBA_x9F_xE5_xBC_x83_xE6_x8E_xA5_xE5_x8F_xA3.html#ga57fe8d047993a1b8011b7a0d334c9801" title="Register image data callback. It was deprecated, and MV_CC_RegisterImageCallBackEx() is recommended.">MV_CC_RegisterImageCallBack()</a> to set image data callback function, and then call <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga78728211c47c6f118110fde635d6ac69" title="Start grabbing images.">MV_CC_StartGrabbing()</a> to start acquisition. The acquired image data will be returned in the set callback function.<br />
 Mode 2: Call <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga78728211c47c6f118110fde635d6ac69" title="Start grabbing images.">MV_CC_StartGrabbing()</a> to start acquisition, and then call <a class="el" href="group___xE5_xBA_x9F_xE5_xBC_x83_xE6_x8E_xA5_xE5_x8F_xA3.html#gad0621c9b4ee6eca2b8ab3432309e11c0" title="Get one frame of image data. It was deprecated, and ::MV_CC_GetOneFrameTimeOut() is recommended.">MV_CC_GetOneFrame()</a> repeatedly in application layer to get frame data of specified pixel format. When getting frame data, the frequency of calling this API should be controlled by upper layer application according to frame rate. <br />
 This API is not supported by <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga45ee1f85623d2a6d3473f62f5cf90a77" title="CameraLink device (serial port).">MV_CAMERALINK_DEVICE()</a> device. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_events__interface_8cpp-example.html#a22">Events_Interface.cpp</a>, <a class="el" href="_grab__asynchronous_8cpp-example.html#a52">Grab_Asynchronous.cpp</a>, <a class="el" href="_grab_image__callback_8cpp-example.html#a43">GrabImage_Callback.cpp</a>, <a class="el" href="_interface_and_device_demo_8cpp-example.html#a23">InterfaceAndDeviceDemo.cpp</a>, <a class="el" href="_parametrize_camera__area_scan_i_o_settings_8cpp-example.html#a46">ParametrizeCamera_AreaScanIOSettings.cpp</a>, <a class="el" href="_parametrize_camera__line_scan_i_o_settings_8cpp-example.html#a44">ParametrizeCamera_LineScanIOSettings.cpp</a>, <a class="el" href="_reconnect_demo_8cpp-example.html#a44">ReconnectDemo.cpp</a>, and <a class="el" href="_trigger__image_callback_8cpp-example.html#a29">Trigger_ImageCallback.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ga78728211c47c6f118110fde635d6ac69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78728211c47c6f118110fde635d6ac69">&#9670;&nbsp;</a></span>MV_CC_StartGrabbing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_CAMCTRL_API int __stdcall MV_CC_StartGrabbing </td>
          <td>(</td>
          <td class="paramtype">IN void *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start grabbing images. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[IN] Device handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return MV_OK for success, and return corresponding <a class="el" href="group___xE9_x94_x99_xE8_xAF_xAF_xE7_xA0_x81.html">error code</a> for failure. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API is not supported by CameraLink device. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_chunk_data_8cpp-example.html#a55">ChunkData.cpp</a>, <a class="el" href="_connect_spec_camera_8cpp-example.html#a22">ConnectSpecCamera.cpp</a>, <a class="el" href="_display_8cpp-example.html#a54">Display.cpp</a>, <a class="el" href="_events_8cpp-example.html#a49">Events.cpp</a>, <a class="el" href="_events__interface_8cpp-example.html#a23">Events_Interface.cpp</a>, <a class="el" href="_grab__asynchronous_8cpp-example.html#a53">Grab_Asynchronous.cpp</a>, <a class="el" href="_grab_image_8cpp-example.html#a46">GrabImage.cpp</a>, <a class="el" href="_grab_image__callback_8cpp-example.html#a44">GrabImage_Callback.cpp</a>, <a class="el" href="_grab_image__high_performance_8cpp-example.html#a51">GrabImage_HighPerformance.cpp</a>, <a class="el" href="_grab_multiple_camera_8cpp-example.html#a50">GrabMultipleCamera.cpp</a>, <a class="el" href="_high_bandwidth_decode_8cpp-example.html#a80">HighBandwidthDecode.cpp</a>, <a class="el" href="_image_process_8cpp-example.html#a41">ImageProcess.cpp</a>, <a class="el" href="_image_save_8cpp-example.html#a103">ImageSave.cpp</a>, <a class="el" href="_interface_and_device_demo_8cpp-example.html#a25">InterfaceAndDeviceDemo.cpp</a>, <a class="el" href="_multi_cast_8cpp-example.html#a53">MultiCast.cpp</a>, <a class="el" href="_multi_light_ctrl__image_stitching_8cpp-example.html#a80">MultiLightCtrl_ImageStitching.cpp</a>, <a class="el" href="_parametrize_camera__area_scan_i_o_settings_8cpp-example.html#a47">ParametrizeCamera_AreaScanIOSettings.cpp</a>, <a class="el" href="_parametrize_camera__line_scan_i_o_settings_8cpp-example.html#a45">ParametrizeCamera_LineScanIOSettings.cpp</a>, <a class="el" href="_quick_software_trigger_8cpp-example.html#a47">QuickSoftwareTrigger.cpp</a>, <a class="el" href="_reconnect_demo_8cpp-example.html#a45">ReconnectDemo.cpp</a>, <a class="el" href="_trigger__image_8cpp-example.html#a49">Trigger_Image.cpp</a>, and <a class="el" href="_trigger__image_callback_8cpp-example.html#a30">Trigger_ImageCallback.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="gae5d7f4ae46a53851f104e26fa449ab06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5d7f4ae46a53851f104e26fa449ab06">&#9670;&nbsp;</a></span>MV_CC_StopGrabbing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_CAMCTRL_API int __stdcall MV_CC_StopGrabbing </td>
          <td>(</td>
          <td class="paramtype">IN void *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>End grabbing images. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[IN] Device handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return MV_OK for success, and return corresponding <a class="el" href="group___xE9_x94_x99_xE8_xAF_xAF_xE7_xA0_x81.html">error code</a> for failure. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API is not supported by CameraLink device. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_chunk_data_8cpp-example.html#a56">ChunkData.cpp</a>, <a class="el" href="_connect_spec_camera_8cpp-example.html#a23">ConnectSpecCamera.cpp</a>, <a class="el" href="_display_8cpp-example.html#a55">Display.cpp</a>, <a class="el" href="_events_8cpp-example.html#a50">Events.cpp</a>, <a class="el" href="_events__interface_8cpp-example.html#a24">Events_Interface.cpp</a>, <a class="el" href="_grab__asynchronous_8cpp-example.html#a54">Grab_Asynchronous.cpp</a>, <a class="el" href="_grab_image_8cpp-example.html#a47">GrabImage.cpp</a>, <a class="el" href="_grab_image__callback_8cpp-example.html#a45">GrabImage_Callback.cpp</a>, <a class="el" href="_grab_image__high_performance_8cpp-example.html#a52">GrabImage_HighPerformance.cpp</a>, <a class="el" href="_grab_multiple_camera_8cpp-example.html#a51">GrabMultipleCamera.cpp</a>, <a class="el" href="_high_bandwidth_decode_8cpp-example.html#a100">HighBandwidthDecode.cpp</a>, <a class="el" href="_image_process_8cpp-example.html#a57">ImageProcess.cpp</a>, <a class="el" href="_image_save_8cpp-example.html#a116">ImageSave.cpp</a>, <a class="el" href="_interface_and_device_demo_8cpp-example.html#a26">InterfaceAndDeviceDemo.cpp</a>, <a class="el" href="_multi_cast_8cpp-example.html#a54">MultiCast.cpp</a>, <a class="el" href="_multi_light_ctrl__image_stitching_8cpp-example.html#a128">MultiLightCtrl_ImageStitching.cpp</a>, <a class="el" href="_parametrize_camera__area_scan_i_o_settings_8cpp-example.html#a48">ParametrizeCamera_AreaScanIOSettings.cpp</a>, <a class="el" href="_parametrize_camera__line_scan_i_o_settings_8cpp-example.html#a46">ParametrizeCamera_LineScanIOSettings.cpp</a>, <a class="el" href="_quick_software_trigger_8cpp-example.html#a48">QuickSoftwareTrigger.cpp</a>, <a class="el" href="_trigger__image_8cpp-example.html#a50">Trigger_Image.cpp</a>, and <a class="el" href="_trigger__image_callback_8cpp-example.html#a31">Trigger_ImageCallback.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ga33331585a4e2a64653b74af66157a6d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33331585a4e2a64653b74af66157a6d8">&#9670;&nbsp;</a></span>MV_CC_GetImageBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_CAMCTRL_API int __stdcall MV_CC_GetImageBuffer </td>
          <td>(</td>
          <td class="paramtype">IN void *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN OUT <a class="el" href="struct_m_v___f_r_a_m_e___o_u_t.html">MV_FRAME_OUT</a> *&#160;</td>
          <td class="paramname"><em>pstFrame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN unsigned int&#160;</td>
          <td class="paramname"><em>nMsec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get one frame of picture using internal buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[IN] Device handle. </td></tr>
    <tr><td class="paramname">pstFrame</td><td>[IN][OUT] Image data and information. </td></tr>
    <tr><td class="paramname">nMsec</td><td>[IN] Timeout duration, unit: millisecond. Input INFINITE to set unlimited timeout period, and image acquisition will not stop until receiving a frame of picture. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return MV_OK for success, and return corresponding <a class="el" href="group___xE9_x94_x99_xE8_xAF_xAF_xE7_xA0_x81.html">error code</a> for failure. </dd></dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>
Before calling this API to get image data frame, you should call <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga78728211c47c6f118110fde635d6ac69" title="Start grabbing images.">MV_CC_StartGrabbing()</a> to start image acquisition. This API gets frame data actively, so the upper layer program should control the frequency of calling this API according to the frame rate. This API supports setting timeout, and SDK will wait to return until data appears. This function will increase the streaming stability, which can be used in the situation with high stability requirement.  </li>
<li>
This API and <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#gaeff416b2d35df148fa2e63521d8847d3" title="Release image buffer. This API is used to release the image buffer which is no longer used,...">MV_CC_FreeImageBuffer()</a> should be called in pairs, after processing the acquired data, you should call <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#gaeff416b2d35df148fa2e63521d8847d3" title="Release image buffer. This API is used to release the image buffer which is no longer used,...">MV_CC_FreeImageBuffer()</a> to release the data pointer permission of pstFrame.  </li>
<li>
This API's streaming buffer is allocated by the SDK internally, so it has higher image acquisition efficiency than MV_CC_GetOneFrameTimeout () , whose streaming buffer needs to be manually allocated by the user.  </li>
<li>
This API cannot be called to stream after calling <a class="el" href="group___xE5_xBA_x9F_xE5_xBC_x83_xE6_x8E_xA5_xE5_x8F_xA3.html#ga3d79377333891ab4f3e9ba352757eca7" title="Display one frame image, register display window, automatic display internally. It was deprecated,...">MV_CC_Display()</a> .  </li>
<li>
This API is not supported by CameraLink device.  </li>
<li>
This API is supported by both USB3 vision camera and GigE camera.  </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_chunk_data_8cpp-example.html#a30">ChunkData.cpp</a>, <a class="el" href="_connect_spec_camera_8cpp-example.html#a2">ConnectSpecCamera.cpp</a>, <a class="el" href="_display_8cpp-example.html#a31">Display.cpp</a>, <a class="el" href="_grab_image_8cpp-example.html#a30">GrabImage.cpp</a>, <a class="el" href="_grab_image__high_performance_8cpp-example.html#a31">GrabImage_HighPerformance.cpp</a>, <a class="el" href="_grab_multiple_camera_8cpp-example.html#a33">GrabMultipleCamera.cpp</a>, <a class="el" href="_high_bandwidth_decode_8cpp-example.html#a83">HighBandwidthDecode.cpp</a>, <a class="el" href="_image_process_8cpp-example.html#a43">ImageProcess.cpp</a>, <a class="el" href="_image_save_8cpp-example.html#a105">ImageSave.cpp</a>, <a class="el" href="_multi_cast_8cpp-example.html#a30">MultiCast.cpp</a>, <a class="el" href="_multi_light_ctrl__image_stitching_8cpp-example.html#a84">MultiLightCtrl_ImageStitching.cpp</a>, <a class="el" href="_quick_software_trigger_8cpp-example.html#a19">QuickSoftwareTrigger.cpp</a>, and <a class="el" href="_trigger__image_8cpp-example.html#a31">Trigger_Image.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="gaeff416b2d35df148fa2e63521d8847d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeff416b2d35df148fa2e63521d8847d3">&#9670;&nbsp;</a></span>MV_CC_FreeImageBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_CAMCTRL_API int __stdcall MV_CC_FreeImageBuffer </td>
          <td>(</td>
          <td class="paramtype">IN void *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN <a class="el" href="struct_m_v___f_r_a_m_e___o_u_t.html">MV_FRAME_OUT</a> *&#160;</td>
          <td class="paramname"><em>pstFrame</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release image buffer. This API is used to release the image buffer which is no longer used, and it should be used with <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga33331585a4e2a64653b74af66157a6d8" title="Get one frame of picture using internal buffer.">MV_CC_GetImageBuffer()</a> in pairs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[IN] Device handle. </td></tr>
    <tr><td class="paramname">pstFrame</td><td>[IN] Image data and information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return MV_OK for success, and return corresponding <a class="el" href="group___xE9_x94_x99_xE8_xAF_xAF_xE7_xA0_x81.html">error code</a> for failure. </dd></dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>
This API and <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga33331585a4e2a64653b74af66157a6d8" title="Get one frame of picture using internal buffer.">MV_CC_GetImageBuffer()</a> should be called in pairs. Before calling <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga33331585a4e2a64653b74af66157a6d8" title="Get one frame of picture using internal buffer.">MV_CC_GetImageBuffer()</a> to get image data pstFrame, you should call this API to release the permission.  </li>
<li>
Compared with the API <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#gafb284e0ae3eeced7e1f9395317800c6f" title="Get one frame of picture, and the SDK waits internally until data is returned.">MV_CC_GetOneFrameTimeout()</a> , this API has higher efficiency of image acquisition. The max. number of nodes that can be outputted from <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga33331585a4e2a64653b74af66157a6d8" title="Get one frame of picture using internal buffer.">MV_CC_GetImageBuffer()</a>(without freeing the buffer) is the same as the "nNum" from API <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga2088ec54d617eb629412729e0241067d" title="Set the number of SDK internal image buffer nodes (no less than 1). It should be called before callin...">MV_CC_SetImageNodeNum()</a> . The default value is 1.  </li>
<li>
This API is not supported by CameraLink device.  </li>
<li>
This API is supported by both USB3 vision camera and GigE camera.  </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_chunk_data_8cpp-example.html#a42">ChunkData.cpp</a>, <a class="el" href="_connect_spec_camera_8cpp-example.html#a7">ConnectSpecCamera.cpp</a>, <a class="el" href="_display_8cpp-example.html#a44">Display.cpp</a>, <a class="el" href="_grab_image_8cpp-example.html#a35">GrabImage.cpp</a>, <a class="el" href="_grab_image__high_performance_8cpp-example.html#a37">GrabImage_HighPerformance.cpp</a>, <a class="el" href="_grab_multiple_camera_8cpp-example.html#a38">GrabMultipleCamera.cpp</a>, <a class="el" href="_high_bandwidth_decode_8cpp-example.html#a89">HighBandwidthDecode.cpp</a>, <a class="el" href="_image_process_8cpp-example.html#a56">ImageProcess.cpp</a>, <a class="el" href="_image_save_8cpp-example.html#a115">ImageSave.cpp</a>, <a class="el" href="_multi_cast_8cpp-example.html#a35">MultiCast.cpp</a>, <a class="el" href="_multi_light_ctrl__image_stitching_8cpp-example.html#a127">MultiLightCtrl_ImageStitching.cpp</a>, <a class="el" href="_quick_software_trigger_8cpp-example.html#a24">QuickSoftwareTrigger.cpp</a>, and <a class="el" href="_trigger__image_8cpp-example.html#a36">Trigger_Image.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="gafb284e0ae3eeced7e1f9395317800c6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb284e0ae3eeced7e1f9395317800c6f">&#9670;&nbsp;</a></span>MV_CC_GetOneFrameTimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_CAMCTRL_API int __stdcall MV_CC_GetOneFrameTimeout </td>
          <td>(</td>
          <td class="paramtype">IN void *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN OUT unsigned char *&#160;</td>
          <td class="paramname"><em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN unsigned int&#160;</td>
          <td class="paramname"><em>nDataSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN OUT <a class="el" href="struct_m_v___f_r_a_m_e___o_u_t___i_n_f_o___e_x.html">MV_FRAME_OUT_INFO_EX</a> *&#160;</td>
          <td class="paramname"><em>pstFrameInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN unsigned int&#160;</td>
          <td class="paramname"><em>nMsec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get one frame of picture, and the SDK waits internally until data is returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[IN] Device handle. </td></tr>
    <tr><td class="paramname">pData</td><td>[OUT] Buffer address used to save image data </td></tr>
    <tr><td class="paramname">nDataSize</td><td>[IN] Buffer size. </td></tr>
    <tr><td class="paramname">pstFrameInfo</td><td>[OUT] Obtained frame information. </td></tr>
    <tr><td class="paramname">nMsec</td><td>[IN] Waiting timeout, unit: millisecond. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return MV_OK for success, and return corresponding <a class="el" href="group___xE9_x94_x99_xE8_xAF_xAF_xE7_xA0_x81.html">error code</a> for failure. </dd></dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>
Before calling this API to get image data frame, you should call <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga78728211c47c6f118110fde635d6ac69" title="Start grabbing images.">MV_CC_StartGrabbing()</a> to start image acquisition. This API gets frame data actively, so the upper layer program should control the frequency of calling this API according to the frame rate. This API supports setting timeout, and SDK will wait to return until data appears. This function will increase the streaming stability, which can be used in the situation with high stability requirement.  </li>
<li>
This API is supported by both the USB3Vision and GIGE camera. </li>
<li>
This API is not supported by CameraLink device. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga90fcfa3fb929d76e99ea7f5946d6c5ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90fcfa3fb929d76e99ea7f5946d6c5ff">&#9670;&nbsp;</a></span>MV_CC_ClearImageBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_CAMCTRL_API int __stdcall MV_CC_ClearImageBuffer </td>
          <td>(</td>
          <td class="paramtype">IN void *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the streaming data buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[IN] Device handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return MV_OK for success, and return corresponding <a class="el" href="group___xE9_x94_x99_xE8_xAF_xAF_xE7_xA0_x81.html">error code</a> for failure. </dd></dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>
You can call this API to clear the needless images in the buffer even when the streaming is in progress. </li>
<li>
You can call this API to clear history data when the continuous mode is switched to the trigger mode.  </li>
<li>
You can call this API to clear internal image buffer of SDK, and image buffer clearing of frame grabbers is not supported.  </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga68d7ec74d6c37907cb868f0ff7f9251e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68d7ec74d6c37907cb868f0ff7f9251e">&#9670;&nbsp;</a></span>MV_CC_GetValidImageNum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_CAMCTRL_API int __stdcall MV_CC_GetValidImageNum </td>
          <td>(</td>
          <td class="paramtype">IN void *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN OUT unsigned int *&#160;</td>
          <td class="paramname"><em>pnValidImageNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of valid images in the current image buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[IN] Device handle. </td></tr>
    <tr><td class="paramname">pnValidImageNum</td><td>[IN][OUT] The number of valid images in the current image buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return MV_OK for success, and return corresponding <a class="el" href="group___xE9_x94_x99_xE8_xAF_xAF_xE7_xA0_x81.html">error code</a> for failure. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API is only used for internal valid images of SDK, not for those of frame grabbers. </dd></dl>

</div>
</div>
<a id="ga2088ec54d617eb629412729e0241067d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2088ec54d617eb629412729e0241067d">&#9670;&nbsp;</a></span>MV_CC_SetImageNodeNum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_CAMCTRL_API int __stdcall MV_CC_SetImageNodeNum </td>
          <td>(</td>
          <td class="paramtype">IN void *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN unsigned int&#160;</td>
          <td class="paramname"><em>nNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the number of SDK internal image buffer nodes (no less than 1). It should be called before calling <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga78728211c47c6f118110fde635d6ac69" title="Start grabbing images.">MV_CC_StartGrabbing()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[IN] Device handle. </td></tr>
    <tr><td class="paramname">nNum</td><td>[IN] The number of SDK internal image buffer nodes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return MV_OK for success, and return corresponding <a class="el" href="group___xE9_x94_x99_xE8_xAF_xAF_xE7_xA0_x81.html">error code</a> for failure. </dd></dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>
Call this API to set the number of SDK internal image buffer nodes. </li>
<li>
Image grabbing methods vary from different camera types. If this API is not called, the default buffer node quantity is different. Take a camera with two USB interfaces as an example, there are 3 buffer nodes by default. </li>
<li>
Allocated node quantity for SDK equals to the pre-allocated node quantity for SDK plus node quantity allocated via this API. <br />
 If memory allocated by the system is insufficient, the pre-allocated node quantity for SDK will be calculated again. In that case, the actually allocated node quantity is based on the calculation of the new pre-allocated node quantity. </li>
<li>
This API is not supported for Camera Link devices. Number of buffer nodes can be connected and set via GenTL for Camera Link devices. <ul>
<li>
</li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="gad337d46cc1955800d4650491ba66e9ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad337d46cc1955800d4650491ba66e9ce">&#9670;&nbsp;</a></span>MV_CC_SetGrabStrategy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_CAMCTRL_API int __stdcall MV_CC_SetGrabStrategy </td>
          <td>(</td>
          <td class="paramtype">IN void *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN <a class="el" href="group___xE6_x9E_x9A_xE4_xB8_xBE_xE7_xB1_xBB_xE5_x9E_x8B_xE5_xAE_x9A_xE4_xB9_x89.html#ga43a073efc6b120886a30b84c96cfa82c">MV_GRAB_STRATEGY</a>&#160;</td>
          <td class="paramname"><em>enGrabStrategy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the streaming strategy. This API is only supported by USB devices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[IN] Device handle. </td></tr>
    <tr><td class="paramname">enGrabStrategy</td><td>[IN] Streaming strategy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return MV_OK for success, and return corresponding <a class="el" href="group___xE9_x94_x99_xE8_xAF_xAF_xE7_xA0_x81.html">error code</a> for failure. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>There are three defined streaming strategies, from which you can choose the suitable one according to the actual requirement. And this API only supports USB devices. <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Macro Definition  </th><th class="markdownTableHeadCenter">Description   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">OneByOne  </td><td class="markdownTableBodyCenter">Get image frames one by one in the chronological order. It is the default strategy.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">LatestImagesOnly  </td><td class="markdownTableBodyCenter">Only get the latest one frame from the output buffer list, and clear the rest images in the list.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">LatestImages  </td><td class="markdownTableBodyCenter">Get the latest image from the output buffer list, and the quantity of frames depends on the parameter OutputQueueSize, value range: [1,ImageNodeNum]. If the OutputQueueSize values "1", the strategy is same to "LatestImagesOnly", and if the OutputQueueSize values "ImageNodeNum", the strategy is same to "OneByOne". You can set the OutputQueueSize via API <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga2d2e6b554356853f307b50b0a0fc3dce" title="Set number of output image buffers, with range of 1 to ImageNodeNum (only valid when MV_GRAB_STRATEGY...">MV_CC_SetOutputQueueSize()</a>, and set the ImageNodeNum via API <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga2088ec54d617eb629412729e0241067d" title="Set the number of SDK internal image buffer nodes (no less than 1). It should be called before callin...">MV_CC_SetImageNodeNum()</a>.   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="ga2d2e6b554356853f307b50b0a0fc3dce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d2e6b554356853f307b50b0a0fc3dce">&#9670;&nbsp;</a></span>MV_CC_SetOutputQueueSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_CAMCTRL_API int __stdcall MV_CC_SetOutputQueueSize </td>
          <td>(</td>
          <td class="paramtype">IN void *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN unsigned int&#160;</td>
          <td class="paramname"><em>nOutputQueueSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set number of output image buffers, with range of 1 to ImageNodeNum (only valid when <a class="el" href="group___xE6_x9E_x9A_xE4_xB8_xBE_xE7_xB1_xBB_xE5_x9E_x8B_xE5_xAE_x9A_xE4_xB9_x89.html#ga43a073efc6b120886a30b84c96cfa82c" title="Streaming strategy.">MV_GRAB_STRATEGY()</a> is set to MV_GrabStrategy_LatestImages). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[IN] Device handle. </td></tr>
    <tr><td class="paramname">nOutputQueueSize</td><td>[IN] Number of output image buffers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return MV_OK for success, and return corresponding <a class="el" href="group___xE9_x94_x99_xE8_xAF_xAF_xE7_xA0_x81.html">error code</a> for failure. </dd></dl>
<dl class="section note"><dt>Note</dt><dd><b>&#160;&bull;&#160;</b>This API must be used with LatestImages Grab strategy, it is used for setting the maximum allowance queue size of the image under the LatestImages strategy. The user may change the output queue size while grabbing images. <b>&#160;&bull;&#160;</b>For a camera with two USB interfaces, the value of nOutputQueueSize should be no less than 2. <b>&#160;&bull;&#160;</b>This API only supports cameras with USB interfaces. </dd></dl>

</div>
</div>
<a id="gac5030eb8498bb2baa031c6b6e8d03406"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5030eb8498bb2baa031c6b6e8d03406">&#9670;&nbsp;</a></span>MV_CC_GetPayloadSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_CAMCTRL_API int __stdcall MV_CC_GetPayloadSize </td>
          <td>(</td>
          <td class="paramtype">IN void *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN OUT uint64_t *&#160;</td>
          <td class="paramname"><em>pnPayloadSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN OUT unsigned int *&#160;</td>
          <td class="paramname"><em>pnAlignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the device payload size (including image data and Chunk data) and memory alignment method, which is used by the application layer to allocate sufficient buffer and correct memory alignment when registering external memory for SDK. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[IN] Device Handle. </td></tr>
    <tr><td class="paramname">pnPayloadSize</td><td>[IN][OUT] Payload size. </td></tr>
    <tr><td class="paramname">pnAlignment</td><td>[IN][OUT] Alignment bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return MV_OK for success, and return corresponding <a class="el" href="group___xE9_x94_x99_xE8_xAF_xAF_xE7_xA0_x81.html">error code</a> for failure. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<div class="footer" style="text-align: right;">
	<hr/>
	<small></small>
</div>
</body>
</html>